<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Executing the Query</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="../index.html" title="QUINCE: QUeries IN C++ Expressions">
<link rel="up" href="../getting_started.html" title="Chapter&#160;3.&#160;Getting Started">
<link rel="prev" href="ceci_n_est_pas_une_pipe.html" title="Ceci n'est pas une pipe">
<link rel="next" href="the_end.html" title="The End">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="ceci_n_est_pas_une_pipe.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../getting_started.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="the_end.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="getting_started.executing_the_query"></a><a class="link" href="executing_the_query.html" title="Executing the Query">Executing the
        Query</a>
</h2></div></div></div>
<pre class="programlisting">
    <span class="keyword">for</span> <span class="special">(</span><span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&amp;</span><span class="identifier">title</span><span class="special">:</span> <span class="identifier">titles_playing_nearby</span><span class="special">)</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">title</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<h4>
<a name="getting_started.executing_the_query.h0"></a>
          <span class="phrase"><a name="getting_started.executing_the_query.remarks"></a></span><a class="link" href="executing_the_query.html#getting_started.executing_the_query.remarks">Remarks</a>
        </h4>
<p>
          This is a C++11 <code class="computeroutput"><span class="keyword">for</span></code> loop.
          In case you haven't seen one of those before, it's as though we had written
          the following (and feel free to enter this code instead, if you prefer
          it):
        </p>
<pre class="programlisting">
    <span class="keyword">for</span> <span class="special">(</span><span class="identifier">query</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;::</span><span class="identifier">const_iterator</span> <span class="identifier">i</span> <span class="special">=</span> <span class="identifier">titles_playing_nearby</span><span class="special">.</span><span class="identifier">begin</span><span class="special">();</span>
         <span class="identifier">i</span> <span class="special">!=</span> <span class="identifier">titles_playing_nearby</span><span class="special">.</span><span class="identifier">end</span><span class="special">();</span>
         <span class="special">++</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
        <span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">&amp;</span><span class="identifier">title</span> <span class="special">=</span> <span class="special">*</span><span class="identifier">i</span><span class="special">;</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">title</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="special">}</span>
</pre>
<p>
          Either way, what the code demonstrates, implicitly in one case and explicitly
          in the other, is that a query has:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
              a <code class="computeroutput"><span class="identifier">begin</span><span class="special">()</span></code>
              method.
            </li>
<li class="listitem">
              a <code class="computeroutput"><span class="identifier">const_iterator</span></code> type,
              with prefix operators <code class="computeroutput"><span class="special">*</span></code>
              and <code class="computeroutput"><span class="special">++</span></code>.
            </li>
<li class="listitem">
              an <code class="computeroutput"><span class="identifier">end</span><span class="special">()</span></code>
              method.
            </li>
</ul></div>
<p>
          The <code class="computeroutput"><span class="identifier">begin</span><span class="special">()</span></code>
          method does most of the work. It translates the query into SQL, maps any
          accompanying data into columns, and sends all of that to the DBMS, which
          starts to execute it. <code class="computeroutput"><span class="identifier">begin</span><span class="special">()</span></code> also creates a <code class="computeroutput"><span class="identifier">const_iterator</span></code>
          object, which is the data structure that receives rows of query output
          as they arrive. Then <code class="computeroutput"><span class="identifier">begin</span><span class="special">()</span></code> waits for the first row (or, for PostgreSQL,
          the first batch or rows); it converts the first row to the query's value
          type (<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code> in our case); and it saves the
          converted item inside the <code class="computeroutput"><span class="identifier">const_iterator</span></code>.
          Finally it returns the <code class="computeroutput"><span class="identifier">const_iterator</span></code>.
          <a href="#ftn.getting_started.executing_the_query.f0" class="footnote" name="getting_started.executing_the_query.f0"><sup class="footnote">[6]</sup></a>
        </p>
<p>
          <code class="computeroutput"><span class="identifier">const_iterator</span></code>'s operator
          <code class="computeroutput"><span class="special">*</span></code> simply returns a const reference
          to the converted item, which the <code class="computeroutput"><span class="identifier">const_iterator</span></code>
          already holds.
        </p>
<p>
          <code class="computeroutput"><span class="identifier">const_iterator</span></code>'s operator
          <code class="computeroutput"><span class="special">++</span></code> gets the next row of output
          (either by finding it in the buffer or by waiting for the the DBMS to produce
          some more), converts that row to the value type, and saves the converted
          item inside the <code class="computeroutput"><span class="identifier">const_iterator</span></code>,
          replacing the previously saved value.
        </p>
<p>
          Eventually a call to <code class="computeroutput"><span class="special">++</span></code> will
          find that there is no more output. Then it will put the <code class="computeroutput"><span class="identifier">const_iterator</span></code>
          into an "end" state. (If there had been no output at at all,
          <code class="computeroutput"><span class="identifier">begin</span><span class="special">()</span></code>
          would have created it in that state.) This is the state where comparisons
          to <code class="computeroutput"><span class="identifier">end</span><span class="special">()</span></code>
          return <code class="computeroutput"><span class="keyword">true</span></code> -- or you can
          test for it directly by calling <code class="computeroutput"><span class="identifier">i</span><span class="special">.</span><span class="identifier">is_end</span><span class="special">()</span></code>.
        </p>
<p>
          The <code class="computeroutput"><span class="identifier">end</span><span class="special">()</span></code>
          method itself does very little. It returns a special <code class="computeroutput"><span class="identifier">const_iterator</span></code>,
          with the property that <em class="replaceable"><code>i</code></em><code class="computeroutput"><span class="special">==</span><span class="identifier">end</span><span class="special">()</span></code>
          reduces to <em class="replaceable"><code>i</code></em><code class="computeroutput"><span class="special">.</span><span class="identifier">is_end</span><span class="special">()</span></code>
          for any <code class="computeroutput"><span class="identifier">const_iterator</span></code>
          <em class="replaceable"><code>i</code></em>.
        </p>
<p>
          Of course the reason quince defines <code class="computeroutput"><span class="identifier">end</span><span class="special">()</span></code> is for interoperability with the C++11
          <code class="computeroutput"><span class="keyword">for</span></code> loop, and with other code
          that is geared towards STL containers. For the same reason, quince defines
          an <code class="computeroutput"><span class="identifier">iterator</span></code> type (a typedef
          of <code class="computeroutput"><span class="identifier">const_iterator</span></code>), and
          within the <code class="computeroutput"><span class="identifier">const_iterator</span></code>
          class you will find such things as a postfix operator <code class="computeroutput"><span class="special">++</span></code>
          (identical to the prefix <code class="computeroutput"><span class="special">++</span></code>,
          since they both return <code class="computeroutput"><span class="keyword">void</span></code>),
          and types <code class="computeroutput"><span class="identifier">pointer</span></code> and
          <code class="computeroutput"><span class="identifier">reference</span></code>, among others.
        </p>
<p>
          The prize for all this STL fancy dress is that our iterators earn the title
          of <a href="http://en.cppreference.com/w/cpp/concept/InputIterator" target="_top"><span class="emphasis"><em>input
          iterators</em></span></a>, which carries certain privileges. E.g. any
          standards-compliant STL implementation must allow:
        </p>
<pre class="programlisting">
    <span class="keyword">const</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">all_of_them</span><span class="special">(</span><span class="identifier">titles_playing_nearby</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">titles_playing_nearby</span><span class="special">.</span><span class="identifier">end</span><span class="special">());</span>
</pre>
<p>
          which populates a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code> by running our query and collecting
          all the results. (Don't expect to <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">sort</span><span class="special">()</span></code> a query however: that function requires
          <span class="emphasis"><em>random access iterators</em></span>, not mere input iterators.)
        </p>
<p>
          Calling <code class="computeroutput"><span class="identifier">begin</span><span class="special">()</span></code>
          is the most general way to execute a query, but it doesn't suit every situation.
          Sometimes you want to retrieve a single record without all the buffering
          apparatus. Sometimes you want to execute a command that is not a query,
          and does not produce even a single record. As we <a class="link" href="../queries/executing.html" title="Executing Queries">shall</a>
          <a class="link" href="../tables/manipulation.html" title="Data Manipulation">see</a>, there is more than one
          way to execute SQL. You don't have to pay for machinery you don't need.
        </p>
<div class="footnotes">
<br><hr style="width:100; text-align:left;margin-left: 0">
<div id="ftn.getting_started.executing_the_query.f0" class="footnote"><p><a href="#getting_started.executing_the_query.f0" class="para"><sup class="para">[6] </sup></a>
            All of these steps rely heavily on the backend library, but our application
            code isn't mentioning that. Quince knows which tables the query was built
            from; it knows which database object we passed to the table constructor
            each time, and it knows the backend-specific type of that database object;
            so we don't need to tell it again.
          </p></div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2014 Michael Shepanski<p>
        Distributed under the Boost Software License, Version 1.0
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="ceci_n_est_pas_une_pipe.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../getting_started.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="the_end.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
